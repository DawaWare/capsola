(()=>{"use strict";function E(t){return Array.isArray?Array.isArray(t):"[object Array]"===Q(t)}const ae=1/0;function y(t){return"string"==typeof t}function G(t){return"number"==typeof t}function V(t){return"object"==typeof t}function M(t){return null!=t}function F(t){return!t.trim().length}function Q(t){return null==t?void 0===t?"[object Undefined]":"[object Null]":Object.prototype.toString.call(t)}const pe=t=>`Invalid value for key ${t}`,me=t=>`Pattern length exceeds max of ${t}.`,Me=t=>`Missing ${t} property in key`,xe=t=>`Property 'weight' in key '${t}' must be a positive integer`,U=Object.prototype.hasOwnProperty;class _e{constructor(e){this._keys=[],this._keyMap={};let s=0;e.forEach(r=>{let n=J(r);s+=n.weight,this._keys.push(n),this._keyMap[n.id]=n,s+=n.weight}),this._keys.forEach(r=>{r.weight/=s})}get(e){return this._keyMap[e]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}function J(t){let e=null,s=null,r=null,n=1,c=null;if(y(t)||E(t))r=t,e=X(t),s=P(t);else{if(!U.call(t,"name"))throw new Error(Me("name"));const i=t.name;if(r=i,U.call(t,"weight")&&(n=t.weight,n<=0))throw new Error(xe(i));e=X(i),s=P(i),c=t.getFn}return{path:e,id:s,weight:n,src:r,getFn:c}}function X(t){return E(t)?t:t.split(".")}function P(t){return E(t)?t.join("."):t}var u={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(t,e)=>t.score===e.score?t.idx<e.idx?-1:1:t.score<e.score?-1:1,includeMatches:!1,findAllMatches:!1,minMatchCharLength:1,location:0,threshold:.6,distance:100,useExtendedSearch:!1,getFn:function ye(t,e){let s=[],r=!1;const n=(c,i,h)=>{if(M(c))if(i[h]){const o=c[i[h]];if(!M(o))return;if(h===i.length-1&&(y(o)||G(o)||function fe(t){return!0===t||!1===t||function de(t){return V(t)&&null!==t}(t)&&"[object Boolean]"==Q(t)}(o)))s.push(function ue(t){return null==t?"":function le(t){if("string"==typeof t)return t;let e=t+"";return"0"==e&&1/t==-ae?"-0":e}(t)}(o));else if(E(o)){r=!0;for(let a=0,f=o.length;a<f;a+=1)n(o[a],i,h+1)}else i.length&&n(o,i,h+1)}else s.push(c)};return n(t,y(e)?e.split("."):e,0),r?s:s[0]},ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1};const Ee=/[^ ]+/g;class j{constructor({getFn:e=u.getFn,fieldNormWeight:s=u.fieldNormWeight}={}){this.norm=function Ie(t=1,e=3){const s=new Map,r=Math.pow(10,e);return{get(n){const c=n.match(Ee).length;if(s.has(c))return s.get(c);const i=1/Math.pow(c,.5*t),h=parseFloat(Math.round(i*r)/r);return s.set(c,h),h},clear(){s.clear()}}}(s,3),this.getFn=e,this.isCreated=!1,this.setIndexRecords()}setSources(e=[]){this.docs=e}setIndexRecords(e=[]){this.records=e}setKeys(e=[]){this.keys=e,this._keysMap={},e.forEach((s,r)=>{this._keysMap[s.id]=r})}create(){this.isCreated||!this.docs.length||(this.isCreated=!0,y(this.docs[0])?this.docs.forEach((e,s)=>{this._addString(e,s)}):this.docs.forEach((e,s)=>{this._addObject(e,s)}),this.norm.clear())}add(e){const s=this.size();y(e)?this._addString(e,s):this._addObject(e,s)}removeAt(e){this.records.splice(e,1);for(let s=e,r=this.size();s<r;s+=1)this.records[s].i-=1}getValueForItemAtKeyId(e,s){return e[this._keysMap[s]]}size(){return this.records.length}_addString(e,s){if(!M(e)||F(e))return;let r={v:e,i:s,n:this.norm.get(e)};this.records.push(r)}_addObject(e,s){let r={i:s,$:{}};this.keys.forEach((n,c)=>{let i=n.getFn?n.getFn(e):this.getFn(e,n.path);if(M(i))if(E(i)){let h=[];const l=[{nestedArrIndex:-1,value:i}];for(;l.length;){const{nestedArrIndex:o,value:a}=l.pop();if(M(a))if(y(a)&&!F(a)){let f={v:a,i:o,n:this.norm.get(a)};h.push(f)}else E(a)&&a.forEach((f,d)=>{l.push({nestedArrIndex:d,value:f})})}r.$[c]=h}else if(y(i)&&!F(i)){let h={v:i,n:this.norm.get(i)};r.$[c]=h}}),this.records.push(r)}toJSON(){return{keys:this.keys,records:this.records}}}function Z(t,e,{getFn:s=u.getFn,fieldNormWeight:r=u.fieldNormWeight}={}){const n=new j({getFn:s,fieldNormWeight:r});return n.setKeys(t.map(J)),n.setSources(e),n.create(),n}function Se(t,{getFn:e=u.getFn,fieldNormWeight:s=u.fieldNormWeight}={}){const{keys:r,records:n}=t,c=new j({getFn:e,fieldNormWeight:s});return c.setKeys(r),c.setIndexRecords(n),c}function $(t,{errors:e=0,currentLocation:s=0,expectedLocation:r=0,distance:n=u.distance,ignoreLocation:c=u.ignoreLocation}={}){const i=e/t.length;if(c)return i;const h=Math.abs(r-s);return n?i+h/n:h?1:i}const L=32;function Le(t){let e={};for(let s=0,r=t.length;s<r;s+=1){const n=t.charAt(s);e[n]=(e[n]||0)|1<<r-s-1}return e}class q{constructor(e,{location:s=u.location,threshold:r=u.threshold,distance:n=u.distance,includeMatches:c=u.includeMatches,findAllMatches:i=u.findAllMatches,minMatchCharLength:h=u.minMatchCharLength,isCaseSensitive:l=u.isCaseSensitive,ignoreLocation:o=u.ignoreLocation}={}){if(this.options={location:s,threshold:r,distance:n,includeMatches:c,findAllMatches:i,minMatchCharLength:h,isCaseSensitive:l,ignoreLocation:o},this.pattern=l?e:e.toLowerCase(),this.chunks=[],!this.pattern.length)return;const a=(d,p)=>{this.chunks.push({pattern:d,alphabet:Le(d),startIndex:p})},f=this.pattern.length;if(f>L){let d=0;const p=f%L,g=f-p;for(;d<g;)a(this.pattern.substr(d,L),d),d+=L;if(p){const m=f-L;a(this.pattern.substr(m),m)}}else a(this.pattern,0)}searchIn(e){const{isCaseSensitive:s,includeMatches:r}=this.options;if(s||(e=e.toLowerCase()),this.pattern===e){let g={isMatch:!0,score:0};return r&&(g.indices=[[0,e.length-1]]),g}const{location:n,distance:c,threshold:i,findAllMatches:h,minMatchCharLength:l,ignoreLocation:o}=this.options;let a=[],f=0,d=!1;this.chunks.forEach(({pattern:g,alphabet:m,startIndex:b})=>{const{isMatch:I,score:O,indices:R}=function we(t,e,s,{location:r=u.location,distance:n=u.distance,threshold:c=u.threshold,findAllMatches:i=u.findAllMatches,minMatchCharLength:h=u.minMatchCharLength,includeMatches:l=u.includeMatches,ignoreLocation:o=u.ignoreLocation}={}){if(e.length>L)throw new Error(me(L));const a=e.length,f=t.length,d=Math.max(0,Math.min(r,f));let p=c,g=d;const m=h>1||l,b=m?Array(f):[];let I;for(;(I=t.indexOf(e,g))>-1;){let x=$(e,{currentLocation:I,expectedLocation:d,distance:n,ignoreLocation:o});if(p=Math.min(x,p),g=I+a,m){let A=0;for(;A<a;)b[I+A]=1,A+=1}}g=-1;let O=[],R=1,v=a+f;const Ve=1<<a-1;for(let x=0;x<a;x+=1){let A=0,w=v;for(;A<w;)$(e,{errors:x,currentLocation:d+w,expectedLocation:d,distance:n,ignoreLocation:o})<=p?A=w:v=w,w=Math.floor((v-A)/2+A);v=w;let oe=Math.max(1,d-w+1),Y=i?f:Math.min(d+w,f)+a,k=Array(Y+2);k[Y+1]=(1<<x)-1;for(let _=Y;_>=oe;_-=1){let C=_-1,he=s[t.charAt(C)];if(m&&(b[C]=+!!he),k[_]=(k[_+1]<<1|1)&he,x&&(k[_]|=(O[_+1]|O[_])<<1|1|O[_+1]),k[_]&Ve&&(R=$(e,{errors:x,currentLocation:C,expectedLocation:d,distance:n,ignoreLocation:o}),R<=p)){if(p=R,g=C,g<=d)break;oe=Math.max(1,2*d-g)}}if($(e,{errors:x+1,currentLocation:d,expectedLocation:d,distance:n,ignoreLocation:o})>p)break;O=k}const H={isMatch:g>=0,score:Math.max(.001,R)};if(m){const x=function Ae(t=[],e=u.minMatchCharLength){let s=[],r=-1,n=-1,c=0;for(let i=t.length;c<i;c+=1){let h=t[c];h&&-1===r?r=c:!h&&-1!==r&&(n=c-1,n-r+1>=e&&s.push([r,n]),r=-1)}return t[c-1]&&c-r>=e&&s.push([r,c-1]),s}(b,h);x.length?l&&(H.indices=x):H.isMatch=!1}return H}(e,g,m,{location:n+b,distance:c,threshold:i,findAllMatches:h,minMatchCharLength:l,includeMatches:r,ignoreLocation:o});I&&(d=!0),f+=O,I&&R&&(a=[...a,...R])});let p={isMatch:d,score:d?f/this.chunks.length:1};return d&&r&&(p.indices=a),p}}class S{constructor(e){this.pattern=e}static isMultiMatch(e){return ee(e,this.multiRegex)}static isSingleMatch(e){return ee(e,this.singleRegex)}search(){}}function ee(t,e){const s=t.match(e);return s?s[1]:null}class te extends S{constructor(e,{location:s=u.location,threshold:r=u.threshold,distance:n=u.distance,includeMatches:c=u.includeMatches,findAllMatches:i=u.findAllMatches,minMatchCharLength:h=u.minMatchCharLength,isCaseSensitive:l=u.isCaseSensitive,ignoreLocation:o=u.ignoreLocation}={}){super(e),this._bitapSearch=new q(e,{location:s,threshold:r,distance:n,includeMatches:c,findAllMatches:i,minMatchCharLength:h,isCaseSensitive:l,ignoreLocation:o})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(e){return this._bitapSearch.searchIn(e)}}class se extends S{constructor(e){super(e)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(e){let r,s=0;const n=[],c=this.pattern.length;for(;(r=e.indexOf(this.pattern,s))>-1;)s=r+c,n.push([r,s-1]);const i=!!n.length;return{isMatch:i,score:i?0:1,indices:n}}}const K=[class be extends S{constructor(e){super(e)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(e){const s=e===this.pattern;return{isMatch:s,score:s?0:1,indices:[0,this.pattern.length-1]}}},se,class Oe extends S{constructor(e){super(e)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(e){const s=e.startsWith(this.pattern);return{isMatch:s,score:s?0:1,indices:[0,this.pattern.length-1]}}},class ke extends S{constructor(e){super(e)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(e){const s=!e.startsWith(this.pattern);return{isMatch:s,score:s?0:1,indices:[0,e.length-1]}}},class Ne extends S{constructor(e){super(e)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(e){const s=!e.endsWith(this.pattern);return{isMatch:s,score:s?0:1,indices:[0,e.length-1]}}},class $e extends S{constructor(e){super(e)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(e){const s=e.endsWith(this.pattern);return{isMatch:s,score:s?0:1,indices:[e.length-this.pattern.length,e.length-1]}}},class Re extends S{constructor(e){super(e)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(e){const r=-1===e.indexOf(this.pattern);return{isMatch:r,score:r?0:1,indices:[0,e.length-1]}}},te],re=K.length,Te=/ +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,Fe=new Set([te.type,se.type]),W=[];function z(t,e){for(let s=0,r=W.length;s<r;s+=1){let n=W[s];if(n.condition(t,e))return new n(t,e)}return new q(t,e)}const B={PATH:"$path",PATTERN:"$val"},D=t=>!(!t.$and&&!t.$or),Ke=t=>!!t[B.PATH],We=t=>!E(t)&&V(t)&&!D(t),ne=t=>({$and:Object.keys(t).map(e=>({[e]:t[e]}))});function ie(t,e,{auto:s=!0}={}){const r=n=>{let c=Object.keys(n);const i=Ke(n);if(!i&&c.length>1&&!D(n))return r(ne(n));if(We(n)){const l=i?n[B.PATH]:c[0],o=i?n[B.PATTERN]:n[l];if(!y(o))throw new Error(pe(l));const a={keyId:P(l),pattern:o};return s&&(a.searcher=z(o,e)),a}let h={children:[],operator:c[0]};return c.forEach(l=>{const o=n[l];E(o)&&o.forEach(a=>{h.children.push(r(a))})}),h};return D(t)||(t=ne(t)),r(t)}function Be(t,e){const s=t.matches;e.matches=[],M(s)&&s.forEach(r=>{if(!M(r.indices)||!r.indices.length)return;const{indices:n,value:c}=r;let i={indices:n,value:c};r.key&&(i.key=r.key.src),r.idx>-1&&(i.refIndex=r.idx),e.matches.push(i)})}function De(t,e){e.score=t.score}let ce=(()=>{class t{constructor(s,r={},n){this.options={...u,...r},this._keyStore=new _e(this.options.keys),this.setCollection(s,n)}setCollection(s,r){if(this._docs=s,r&&!(r instanceof j))throw new Error("Incorrect 'index' type");this._myIndex=r||Z(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(s){M(s)&&(this._docs.push(s),this._myIndex.add(s))}remove(s=(()=>!1)){const r=[];for(let n=0,c=this._docs.length;n<c;n+=1){const i=this._docs[n];s(i,n)&&(this.removeAt(n),n-=1,c-=1,r.push(i))}return r}removeAt(s){this._docs.splice(s,1),this._myIndex.removeAt(s)}getIndex(){return this._myIndex}search(s,{limit:r=-1}={}){const{includeMatches:n,includeScore:c,shouldSort:i,sortFn:h,ignoreFieldNorm:l}=this.options;let o=y(s)?y(this._docs[0])?this._searchStringList(s):this._searchObjectList(s):this._searchLogical(s);return function ze(t,{ignoreFieldNorm:e=u.ignoreFieldNorm}){t.forEach(s=>{let r=1;s.matches.forEach(({key:n,norm:c,score:i})=>{const h=n?n.weight:null;r*=Math.pow(0===i&&h?Number.EPSILON:i,(h||1)*(e?1:c))}),s.score=r})}(o,{ignoreFieldNorm:l}),i&&o.sort(h),G(r)&&r>-1&&(o=o.slice(0,r)),function He(t,e,{includeMatches:s=u.includeMatches,includeScore:r=u.includeScore}={}){const n=[];return s&&n.push(Be),r&&n.push(De),t.map(c=>{const{idx:i}=c,h={item:e[i],refIndex:i};return n.length&&n.forEach(l=>{l(c,h)}),h})}(o,this._docs,{includeMatches:n,includeScore:c})}_searchStringList(s){const r=z(s,this.options),{records:n}=this._myIndex,c=[];return n.forEach(({v:i,i:h,n:l})=>{if(!M(i))return;const{isMatch:o,score:a,indices:f}=r.searchIn(i);o&&c.push({item:i,idx:h,matches:[{score:a,value:i,norm:l,indices:f}]})}),c}_searchLogical(s){const r=ie(s,this.options),n=(l,o,a)=>{if(!l.children){const{keyId:d,searcher:p}=l,g=this._findMatches({key:this._keyStore.get(d),value:this._myIndex.getValueForItemAtKeyId(o,d),searcher:p});return g&&g.length?[{idx:a,item:o,matches:g}]:[]}const f=[];for(let d=0,p=l.children.length;d<p;d+=1){const m=n(l.children[d],o,a);if(m.length)f.push(...m);else if("$and"===l.operator)return[]}return f},i={},h=[];return this._myIndex.records.forEach(({$:l,i:o})=>{if(M(l)){let a=n(r,l,o);a.length&&(i[o]||(i[o]={idx:o,item:l,matches:[]},h.push(i[o])),a.forEach(({matches:f})=>{i[o].matches.push(...f)}))}}),h}_searchObjectList(s){const r=z(s,this.options),{keys:n,records:c}=this._myIndex,i=[];return c.forEach(({$:h,i:l})=>{if(!M(h))return;let o=[];n.forEach((a,f)=>{o.push(...this._findMatches({key:a,value:h[f],searcher:r}))}),o.length&&i.push({idx:l,item:h,matches:o})}),i}_findMatches({key:s,value:r,searcher:n}){if(!M(r))return[];let c=[];if(E(r))r.forEach(({v:i,i:h,n:l})=>{if(!M(i))return;const{isMatch:o,score:a,indices:f}=n.searchIn(i);o&&c.push({score:a,key:s,value:i,idx:h,norm:l,indices:f})});else{const{v:i,n:h}=r,{isMatch:l,score:o,indices:a}=n.searchIn(i);l&&c.push({score:o,key:s,value:i,norm:h,indices:a})}return c}}return t.version="6.6.2",t.createIndex=Z,t.parseIndex=Se,t.config=u,t})();ce.parseQuery=ie,function je(...t){W.push(...t)}(class Pe{constructor(e,{isCaseSensitive:s=u.isCaseSensitive,includeMatches:r=u.includeMatches,minMatchCharLength:n=u.minMatchCharLength,ignoreLocation:c=u.ignoreLocation,findAllMatches:i=u.findAllMatches,location:h=u.location,threshold:l=u.threshold,distance:o=u.distance}={}){this.query=null,this.options={isCaseSensitive:s,includeMatches:r,minMatchCharLength:n,findAllMatches:i,ignoreLocation:c,location:h,threshold:l,distance:o},this.pattern=s?e:e.toLowerCase(),this.query=function Ce(t,e={}){return t.split("|").map(s=>{let r=s.trim().split(Te).filter(c=>c&&!!c.trim()),n=[];for(let c=0,i=r.length;c<i;c+=1){const h=r[c];let l=!1,o=-1;for(;!l&&++o<re;){const a=K[o];let f=a.isMultiMatch(h);f&&(n.push(new a(f,e)),l=!0)}if(!l)for(o=-1;++o<re;){const a=K[o];let f=a.isSingleMatch(h);if(f){n.push(new a(f,e));break}}}return n})}(this.pattern,this.options)}static condition(e,s){return s.useExtendedSearch}searchIn(e){const s=this.query;if(!s)return{isMatch:!1,score:1};const{includeMatches:r,isCaseSensitive:n}=this.options;e=n?e:e.toLowerCase();let c=0,i=[],h=0;for(let l=0,o=s.length;l<o;l+=1){const a=s[l];i.length=0,c=0;for(let f=0,d=a.length;f<d;f+=1){const p=a[f],{isMatch:g,indices:m,score:b}=p.search(e);if(!g){h=0,c=0,i.length=0;break}c+=1,h+=b,r&&(Fe.has(p.constructor.type)?i=[...i,...m]:i.push(m))}if(c){let f={isMatch:!0,score:h/c};return r&&(f.indices=i),f}}return{isMatch:!1,score:1}}});let T=[];addEventListener("message",({data:t})=>{if(console.log("worker got message: ",t),t.drugs&&t.drugs.length>0&&(T=t.drugs),t.searchTerm&&t.searchTerm.length>0&&"exact"===t.searchType){const e=Ge(T,t.searchKey,t.searchTerm);postMessage(e)}else if(t.searchTerm&&t.searchTerm.length>0&&"approximate"===t.searchType){const e=Ye(T,t.searchKey,t.searchTerm);postMessage(e)}else postMessage(T)});const Ye=(t,e,s)=>new ce(t,{shouldSort:!0,threshold:.6,location:0,distance:100,maxPatternLength:32,minMatchCharLength:1,keys:[e]}).search(s).map(i=>i.item),Ge=(t,e,s)=>t.filter(n=>n[e].toLowerCase().includes(s.toLowerCase()))})();